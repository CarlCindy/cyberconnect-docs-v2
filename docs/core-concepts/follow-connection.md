---
id: follow-connection
title: Follow
slug: /concepts/follow-connection
sidebar_label: Follow (Connections üë•) 
sidebar_position: 4
description: Off-chain connections supported
---

## 1. Follow

Follow is the simplest form of unilateral connection where one ccProfile follows another ccProfile. This profile to profile following connection is represented as a ERC721 NFT on whichever EVM chain it's being deployed on. This is great for applications with light weight social graph needs like following another user‚Äôs wallet activity.

![follow-gif](/img/v2/follow-gif.gif)

### Idempotent Proof of Connection and Content

Social platforms like Twitter have millions of new connections and posts generated by users every single day. Therefore, the data standard has to be efficient and good to work in at the same time to support scaling.

Take connection data as an example, a rather simple way of doing this would be to put all your following in a list and append the address to the list when a user follows someone new and remove the address from the list when an unfollow action takes place. However, this approach will require the data store and compute engine to provide an ACID guarantee to work in multi-thread scenarios like following multiple people or following and unfollowing in a short time span. Furthermore, the ACID guarantee does not come cheap in a decentralized setting.

Therefore, we adopt idempotent proof to describe the most up-to-date state for connections between any two addresses and content created by users. The benefit of using idempotency is for easy conflict resolution without an ACID guarantee. Instead of using a data model like ‚Äúfollowing list‚Äù where each new following address gets appended to the same list, we describe the social connections as each individual pair of addresses' final desired state (following or not) at that timestamp.

There could only exist one state per any two addresses per operation, e.g. Alice could either only be following or not following Bob. The proof connection includes the following details of the desired state between an originator and a target address (The content proof has a similar structure):

```json
type Proof = {
  /** Name of the operation. E.g, Follow */
  name: string;
  /** State of the operation, E.g, true or false for following or not */
  state: boolean;
  /** The originator address */
  from: string;
  /** The target address */
  to: string;
  /** Which dApp is this connection originated */
  namespace: string;
  /** Which network is this connection on */
  network: string;
  /** timestamp */
  timestamp: number;
}
```

We only describe these data standard in the raw object format. However, the final message being sent to CyberConnect Social Data Network would be encoded with both a digest of the message and a signature signed by the owner. We leave this signing process to be generic so that it‚Äôs compatible with Ceramic‚Äôs IPLD encoding with DAG-JOSE or with a simpler JSON Blob format.

## Data Integrity & Availability

For a decentralized data network, we must ensure data availability (that data cannot be censored) and data integrity (that data cannot be modified in an unauthorized manner). The CyberConnect protocol adopts a hybrid model for different data use cases depending on the write frequency and amount of data.

For the user profile data model, we directly use Ceramic as a data store that already provides data availability through its IPFS compatible file structures and data integrity through anchoring a Merkle root of the new file updates on a blockchain. Since user profile data is less frequently written and the number of files in existence is linearly proportional to the existing user base, Ceramic is the perfect solution here.

For the idempotent proof, since users collectively would create millions of records on a social platform, it would be impossible to store everything on Ceramic at its current scale while also providing the high level of service-level agreement (SLA) to dApp developers.

Thus, we designed a mechanism for safely dealing with writes and updates to connections between users using a hash-linked list and a decentralized data store. Each address pair (for connection proof) and an operation would create a new hashed link list called ‚Äòoperation log‚Äô upon the first transaction. Each update to the state (changing from following to unfollowing) would append a new node with the new state to the tail of the operation log. Each new state is stored locally on a central server until a batch upload logic uploads the tail of each operation log to a decentralized file storage system like Arweave or IPFS.

Every node in that operation log is stored locally on a central server for caching and serving fast queries. Users could verify data integrity by getting the latest connection state between any two addresses and traverse through the hashed link list by requesting the previous node from the central server. We assume a trusted central server here since the data availability requires the central node to respond to these data queries. We believe this is a sufficiently decentralized and highly performant system.

![linkedlist](/img/v2/linkedlist.png)
