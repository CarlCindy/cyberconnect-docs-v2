---
id: follow-connection
title: Follow
slug: /core-concepts/follow-connection
sidebar_label: Follow (Connections üë•) 
sidebar_position: 4
description: Off-chain connections supported
---

Unlike SubscribeNFT, the follow feature offers developers/users **a cheaper alternative** of establishing **uni-directional relationships between addresses & ccProfiles**. 

The lower cost comes from the architecture of this connection. Instead of minting another profiles' SubscribeNFT, the follow feature takes advantage of [Ceramic](https://ceramic.network/)'s decentralized data network and asymmetric cryptography to establish the connection. It does not require any on-chain transaction and therefore users/applications do not have to pay gas. This is great for applications with light weight social graph needs.

![follow-gif](/img/v2/follow-gif.gif)

## How does it work? 

To achieve data sovereignty, every connection and content on CyberConnect has to be signed by a cryptographic key pair, meaning that only the person with the private key could have produced such connection and content. This mechanism is designed in a manner that is both easy to use and future-proof.

When a user interacts with CyberConnect through a dApp for the first time, they would create a key pair on the device and publish the public key to the CyberConnect Social Data Network. We support a variety of Elliptic Curve Digital Signature Algorithms (ECDSA) for compatibility. As a user initiates an action, the previously generated private key will be loaded from the local environment to sign the message.

The following section will explain how nodes in the network run the job of storing these signed data. It is worth noting that at the same time, the Social Data Network is compatible with Ceramic‚Äôs DID design to enable some data to be easily stored on Ceramic.

### User Profile

Each user should have a dedicated space for storing relevant social profile information. We adopted Ceramic‚Äôs BasicProfile schema as a starting point and added the CyberProfile schema for users to append arbitrary content blocks. The following is a pseudo schema in Typescript. All raw images for background and avatar are stored on IPFS or other decentralized data stores.

```js
type Profile = {
    /** Profile background picture, hash of IPFS address. */
    backgroundPicture: string,
    /** Bio, up to 1,000 characters. */
    bio: string,
    /** Blocks belonging to the profile, ordered. */
    blocks: Array<Block>,
    /** Display name of the profile, standard: 1-20 characters; letters, numbers, and blanks only. */
    displayName: string,
    /** Handle of the profile. */
    handle: string,
    /** Profile avatar picture, hash of IPFS address. */
    profilePicture: string,
    /** Twitter verification info of the profile. */
    twitterVerification: TwitterVerification,
};
```


### Idempotent Proof of Connection and Content

Social platforms like Twitter have millions of new connections and posts generated by users every single day. Therefore, the data standard has to be efficient and good to work in at the same time to support scaling.

Take connection data as an example, a rather simple way of doing this would be to put all your following in a list and append the address to the list when a user follows someone new and remove the address from the list when an unfollow action takes place. However, this approach will require the data store and compute engine to provide an ACID guarantee to work in multi-thread scenarios like following multiple people or following and unfollowing in a short time span. Furthermore, the ACID guarantee does not come cheap in a decentralized setting.

Therefore, we adopt idempotent proof to describe the most up-to-date state for connections between any two addresses and content created by users. The benefit of using idempotency is for easy conflict resolution without an ACID guarantee. Instead of using a data model like ‚Äúfollowing list‚Äù where each new following address gets appended to the same list, we describe the social connections as each individual pair of addresses' final desired state (following or not) at that timestamp.

There could only exist one state per any two addresses per operation, e.g. Alice could either only be following or not following Bob. The proof connection includes the following details of the desired state between an originator and a target address (The content proof has a similar structure):

```json
type Proof = {
  /** Name of the operation. E.g, Follow */
  name: string;
  /** State of the operation, E.g, true or false for following or not */
  state: boolean;
  /** The originator address */
  from: string;
  /** The target address */
  to: string;
  /** Which dApp is this connection originated */
  namespace: string;
  /** Which network is this connection on */
  network: string;
  /** timestamp */
  timestamp: number;
}
```

We only describe these data standard in the raw object format. However, the final message being sent to CyberConnect Social Data Network would be encoded with both a digest of the message and a signature signed by the owner. We leave this signing process to be generic so that it‚Äôs compatible with Ceramic‚Äôs IPLD encoding with DAG-JOSE or with a simpler JSON Blob format.

## Data Integrity & Availability

For a decentralized data network, we must ensure data availability (that data cannot be censored) and data integrity (that data cannot be modified in an unauthorized manner). The CyberConnect protocol adopts a hybrid model for different data use cases depending on the write frequency and amount of data.

For the user profile data model, we directly use Ceramic as a data store that already provides data availability through its IPFS compatible file structures and data integrity through anchoring a Merkle root of the new file updates on a blockchain. Since user profile data is less frequently written and the number of files in existence is linearly proportional to the existing user base, Ceramic is the perfect solution here.

For the idempotent proof, since users collectively would create millions of records on a social platform, it would be impossible to store everything on Ceramic at its current scale while also providing the high level of service-level agreement (SLA) to dApp developers.

Thus, we designed a mechanism for safely dealing with writes and updates to connections between users using a hash-linked list and a decentralized data store. Each address pair (for connection proof) and an operation would create a new hashed link list called ‚Äòoperation log‚Äô upon the first transaction. Each update to the state (changing from following to unfollowing) would append a new node with the new state to the tail of the operation log. Each new state is stored locally on a central server until a batch upload logic uploads the tail of each operation log to a decentralized file storage system like Arweave or IPFS.

Every node in that operation log is stored locally on a central server for caching and serving fast queries. Users could verify data integrity by getting the latest connection state between any two addresses and traverse through the hashed link list by requesting the previous node from the central server. We assume a trusted central server here since the data availability requires the central node to respond to these data queries. We believe this is a sufficiently decentralized and highly performant system.

![linkedlist](/img/v2/linkedlist.png)
